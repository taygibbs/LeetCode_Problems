# LeetCode Problem Solution Notes/Thoughts
 Wrote by Taylor Gibbons with the intent to practice coding concepts

## Table of Contents:
1. [twoSum Problem](#1.)


# Problems: 
## 1. twoSum Problem:
**[TASK]** In this problem, the task is to find the indices of a list that will sum to a target number. For example:  `nums = [2,7,11,15]` and `target = 9`. The resulting output will be `soln = [0,1]` because those correspond to the numbers 2 and 7, which sum up to 9.

**[PROCESS]** The first thing that came to mind when dealing with this problem is how I would go along solving it as a math problem. Intuitively, I would go from the first element, add it with the second, see if it is equal to the target, and if not, then move to the next element, where the first element is now added with the third, then checked and repeated. Then if the first and last elements do not match, it moves to checking if the second value added with any of the other values equals target, and thus continues. To put this into code, I made two `for` loops where the first loop is the initial value that will be added to the others, and the inner loop is the loop running through the rest of the values. Then it would check to see if the sum is equal to the target. If it were equal, it would break the loops and return the indices; if not equal, it would run the loop again with the initial value moved over one. 

## 2. addTwoNumbers Problem:
**[TASK]** In this problem, the task is to take two linked lists (that are backward), add the numbers (as integers) to each other, and then separate back into a list of numbers. For example: `l1 = [2,4,3], l2 = [5,6,4]` and the output would be `soln = [7,0,8]` because the integer reversed is `342 + 465 = 807`, then reversed again. 

**[PROCESS]** This problem didn't seem to difficult to me due to some of the list operations that could be used. The first thing that I thought of was using the `.reverse()` function to reverse the lists, then use `''.join()` to combine the integers in the list together. However, using just the join function did not work and I had to figure out a way to fix this. This was done by looking into the join function and finding out that since the elements in the list are integers, they will not be joined together since it looks for strings. To get around this, I found a way to go through each index of the list, turning it into a string, combining it, then returning the combined string into an integer; `int(''.join([str(i) for i in l1]))`. This resulted in the list elements being a combined integer, which then could be added to the other list's integer. From there, the newly made list is separated into a list and reversed.

This is about the time that I ended up realizing that I messed up and was thinking that the problem was dealing with lists, not ListNodes. So the original code that I had made does not work for the actual problem. This made it a bit more difficult since I am not used to linked lists and this would be a bit of a learning curve for me. Thus I took this as a sign to work on a linked list tutorial and eventually try to figure out the problem. Thus, this problem is still being worked on while I am working on other problems.

## 3. lengthOfLongestSubstring Problem:
**[TASK]** In this problem, the task is to find the length of the longest substring, of a larger string, without having any repeated letters. For example: `s = "abcabcbb"` will result with `num = 3` since the longest substring without a repeat is `"abc"`.

**[PROCESS]** When planning out how I was going to tackle this problem, I decided to try to think of it logically. If I had the function start with the first letter of the string, then check to make sure that the next letter in the string, has not been already added. If it has been added, it will take note of the length of the temp string, then restart by adding the next string letter and checking. To better show my thinking about this problem, I made a simple ![flowchart](https://github.com/taygibbs/LeetCode_Problems/tree/main/Flowcharts/Problem3FC.PNG?raw=true) that shows the general flow of my thinking. 
With this idea, I made a function that I thought would work, and I got really close. However, the only time that this function I made does not work is when the string is a single letter repeated several times. Due to this, I will keep working on it, but I did end up researching ways to work on this problem. The next way that I saw would work for a problem similar to this is called a sliding window, where instead of looking through each letter and checking each new letter to see if it is in the temp string, it slides a "window" that covers the looked at elements, and then checks if the next element is in that window. If it is, then the window is noted and it starts over; if not, it will increase the window size to cover the new letter and move to the next. 

## 4. findMedianSortedArrays Problem:
**[TASK]** In this problem, the task is to find the median value of two arrays, both of which are sorted before entering the function. For example, `l1 = [1,4]` and `l2 = [2,3,5]` then the median value would be found from the list `l3 = [1,2,3,4,5]` where the median is 3.

**[PROCESS]** Having done a faily similar problem in one of my math classes where I had to deal with a non-sorted list in MatLab, I figured this would be a pretty easy one to deal with. The first thing that I did was make sure to check to see which list was smaller and then append the larger list with the smaller, then (though I know its relatively inefficient) I used the sort() function to sort that list. From there, I know there is two cases that determine how the median is found. If the list is composed of an odd amount of element, then the median will be the middle most element. If the list had an even number of elements, then it would be the two middle most values averaged. The odd number case was pretty easy to deal with by dividing the number of elements by two and rounding down (using the `//` operator). The even case is similar where I used the same operator and then averaged the value that was in the found index with the number in the next index. Thus, the medians can be found. 

## 7. reverseInteger Problem:
**[TASK]** In this problem, the task is to take in an integer and reverse it. This includes making sure that if the integer is negative when it comes in, it will be negative out.

**[PROCESS]** For this problem, I decided to start by thinking of it as dealing with a string. The first thing to do was to change the integer into a string and check to see if the first element is a negative sign. From there, the string is reassigned to the rest of the string after the negative, then it is reversed and retyped into an integer. If it was negative before, the function makes the newly reversed integer negative and sends it back.

## 8. stringToInteger(atoi)
**[TASK]** In this problem, the task is to take in a string and convert the first group of numbers into an integer. This will take into account negative signs to make the output integer negative, and if there is any non-number found before an integer, it'll automatically stop and say there are 0 integers. For example, the string `"    042"` will result with `num = 42`, and `"words and 987"` will result with `num = 0`.

**[PROCESS]** For this problem, I immediately decided to use a use a try/except block to see if a part of the string was able to be turned into an integer, and if it wasn't that would be a way to tell to start or end the loop. It starts with an empty temp string and starts looping through each element of the string that was passed in. Using a match case structure, and an if statement, it checks to see if there have been any numbers added to the temp string and if the current letter is a space or +/-, it will take note, then continue on. If the next element is not a space or a number, the function stops and returns 0. If the current element can be turned into an integer, it gets added into the temp string. After adding numbers or not finding a number before an unacceptable symbol, the loop will stop and turn whatever numbers added into the temp string into an integer; if a negative sign was found, it will make the integer negative. Thus, the string will have found the earliest numbers and turn it into an integer (if there is any numbers before letters)

## 88. mergeSortedArrays Problem
**[TASK]** In this problem, the task is to merge two arrays that are in ascending order resulting in a list that is also in ascending order (without the use of the sort() function); there are also integers `m & n` that is the number of elements that are to be merged (ie, if `m = 2` and the array is 3, it'll only merge the first two). For example, `nums1 = [1,3,5], n = 3` and `nums2 = [2,4], m = 2` results with `nums1 = [1,2,3,4,5]`.

**[PROCESS]** When I initially started thinking about this problem, my idea was to start at the first element of the array with the lowest value (in the case of the examples, it would start with nums 1) and loop through the smaller array. It starts by assigning the first value of the other list as a temp integer and see if it is less or more than the first value in the larger array. If it was less, then it would move the larger values up an index and insert the current value. This was the process I was trying to impliment, however, I soon realized that this was a much to inefficient way of thinking about it and I was not able to get it to work the way I was thinking. After taking some time to research and look at discussions regarding this problem, one of the biggest tips was to think of this problem backward. Instead of going through each element one at a time and sorting it that way, I needed to think of it as going through both lists at the same time backward. It starts at the elements of `m & n` of both lists and compares them; since we know that the lists are already sorted ascendingly, one of the two elements WILL be the largest number in the merged set. So, whichever of the two is the larger, the `m+n` index will be assigned that larger value. Then whatever set that value came from, the index will have 1 subtracted, meaning we will be looking at a lesser number than we have just looked at. From here, it repeats the process by checking to see which sets element is larger, assigns it to the furthermost not filled index of the merged list and alternates sets until both lists have been gone through. 